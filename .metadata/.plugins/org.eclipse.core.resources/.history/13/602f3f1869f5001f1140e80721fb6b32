/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body for the PrivTag BLE application.
  *                   When the tag is dropped (i.e. no motion for one minute),
  *                   it becomes discoverable and every 10 seconds sends via BLE
  *                   the message: "DS12345 lost: X sec" (where X is seconds lost).
  ******************************************************************************
  * @attention
  *
  * This file is the only file that you are allowed to modify.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "ble.h"
#include "i2c.h"
#include "lsm6dsl.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

/* External BLE handles from ble.c (defined in ble.h or declared as extern) */
extern uint8_t NORDIC_UART_SERVICE_HANDLE[];
extern uint8_t READ_CHAR_HANDLE[];

/* Define movement detection and lost-mode parameters */
#define MOVEMENT_THRESHOLD    1200    // If change in any axis is above this value, consider it movement
#define LOST_MODE_TIMEOUT_MS  60000   // 60 seconds with no movement triggers lost mode
#define BLE_MESSAGE_INTERVAL  10000   // Every 10,000 ms (10 seconds) send a BLE message

/* Tag name (for BLE messages) */
#define TAG_NAME "DS12345"  // Please mention "DS12345" (the last 4 digits of your PID) in your README.md

/* Private function prototypes */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_SPI3_Init(void);

/* Redefine the _write() function for printf output via ITM */
int _write(int file, char *ptr, int len)
{
  for (int i = 0; i < len; i++)
  {
    ITM_SendChar(*ptr++);
  }
  return len;
}

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* HAL initialization */
  HAL_Init();
  SystemClock_Config();

  /* Initialize peripherals for BLE (SPI, GPIO) */
  MX_GPIO_Init();
  MX_SPI3_Init();

  /* Reset BLE module */
  HAL_GPIO_WritePin(BLE_RESET_GPIO_Port, BLE_RESET_Pin, GPIO_PIN_RESET);
  HAL_Delay(10);
  HAL_GPIO_WritePin(BLE_RESET_GPIO_Port, BLE_RESET_Pin, GPIO_PIN_SET);

  /* Initialize BLE module */
  ble_init();

  /* Initially, set BLE as non-discoverable */
  setDiscoverability(0);

  /* Initialize I2C and the accelerometer (LSM6DSL) */
  i2c_init();
  lsm6dsl_init();

  /* Variables for accelerometer motion detection */
  uint32_t lastMotionTime = HAL_GetTick();  // Last time movement was detected
  uint32_t lostStartTime = 0;               // Time when lost mode was entered
  uint32_t lastBLEMessageTime = 0;          // Last time a BLE message was sent
  bool lostMode = false;                    // Lost mode flag

  int16_t ax, ay, az;         // Current accelerometer readings
  int16_t prev_ax, prev_ay, prev_az;  // Previous readings

  /* Get an initial accelerometer reading */
  lsm6dsl_read_xyz(&prev_ax, &prev_ay, &prev_az);

  printf("PrivTag application started. Monitoring movement...\r\n");

  /* Main loop */
  while (1)
  {
    /* Read current accelerometer values */
    lsm6dsl_read_xyz(&ax, &ay, &az);

    /* Compute differences on each axis */
    int diff_x = abs(ax - prev_ax);
    int diff_y = abs(ay - prev_ay);
    int diff_z = abs(az - prev_az);

    /* If any axis shows significant change, update lastMotionTime */
    if(diff_x > MOVEMENT_THRESHOLD || diff_y > MOVEMENT_THRESHOLD || diff_z > MOVEMENT_THRESHOLD)
    {
      lastMotionTime = HAL_GetTick();
      /* If we were in lost mode, exit lost mode and disable BLE discoverability */
      if(lostMode)
      {
        lostMode = false;
        setDiscoverability(0);
        printf("Movement detected. Exiting lost mode.\r\n");
      }
    }

    /* Check if no movement for one minute */
    if((HAL_GetTick() - lastMotionTime) >= LOST_MODE_TIMEOUT_MS)
    {
      if(!lostMode)
      {
        /* Enter lost mode */
        lostMode = true;
        lostStartTime = HAL_GetTick();
        lastBLEMessageTime = HAL_GetTick();
        setDiscoverability(1);
        printf("No movement detected for one minute. Entering lost mode.\r\n");
      }
    }

    /* If in lost mode, every 10 seconds send a BLE message */
    if(lostMode && ((HAL_GetTick() - lastBLEMessageTime) >= BLE_MESSAGE_INTERVAL))
    {
      uint32_t secondsLost = (HAL_GetTick() - lostStartTime) / 1000;
      char message[50];
      /* Construct a short message that fits in a BLE packet */
      snprintf(message, sizeof(message), "%s lost: %lu sec", TAG_NAME, secondsLost);

      /* Send the message over BLE using the virtual UART service */
      updateCharValue(NORDIC_UART_SERVICE_HANDLE, READ_CHAR_HANDLE, 0, strlen(message), (uint8_t*)message);
      printf("Sent BLE message: %s\r\n", message);

      lastBLEMessageTime = HAL_GetTick();
    }

    /* Update previous accelerometer readings */
    prev_ax = ax;
    prev_ay = ay;
    prev_az = az;

    /* Delay ~100 ms before next sample */
    HAL_Delay(100);
  }
}

/* System Clock Configuration, SPI3, and GPIO initialization functions are as provided in the project.
   (They are not modified for this step.)
*/

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
    Error_Handler();
  }
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_7;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief SPI3 Initialization Function
  * @retval None
  */
static void MX_SPI3_Init(void)
{
  /* SPI3 parameter configuration*/
  hspi3.Instance = SPI3;
  hspi3.Init.Mode = SPI_MODE_MASTER;
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
  hspi3.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi3.Init.NSS = SPI_NSS_SOFT;
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi3.Init.CRCPolynomial = 7;
  hspi3.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief GPIO Initialization Function
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();

  /* Configure BLE interrupt pin */
  GPIO_InitStruct.Pin = BLE_INT_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BLE_INT_GPIO_Port, &GPIO_InitStruct);

  /* Configure GPIO pins for BLE reset and LED1 */
  GPIO_InitStruct.Pin = GPIO_LED1_Pin | BLE_RESET_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* Configure BLE chip select pin */
  GPIO_InitStruct.Pin = BLE_CS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(BLE_CS_GPIO_Port, &GPIO_InitStruct);
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  __disable_irq();
  while (1)
  {
  }
}
