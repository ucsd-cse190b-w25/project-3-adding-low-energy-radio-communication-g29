/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body for DS12345 PrivTag BLE application.
  *                   This application uses an I2C-connected accelerometer to monitor
  *                   movement. If no movement is detected for ~5 seconds (for testing),
  *                   the tag enters lost mode. In lost mode, the tag:
  *                      - Flashes a lost-mode LED pattern (preamble + PID + lost minutes),
  *                      - Calls setConnectable() to enable BLE advertising,
  *                      - Every 10 seconds sends a BLE message over the virtual UART in the format:
  *                          "PrivTag DS12345 has been missing for <N> seconds"
  *                   If movement is detected, lost mode is immediately exited.
  *
  * Relevant documentation:
  *   - BlueNRG-MS datasheet (Chapter 6, Operating Modes)
  *   - BlueNRG-MS ACI documentation
  *   - Bluetooth Core Specification V6
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "i2c.h"
#include "lsm6dsl.h"
#include "leds.h"
#include "timer.h"
#include "ble.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Private defines -----------------------------------------------------------*/
#define MOVEMENT_THRESHOLD    1200    // Max difference to consider static
#define LOST_MODE_THRESHOLD   50      // ~50 samples (~5 seconds with 100ms delay)
#define ONE_MINUTE_COUNT      600     // 600 iterations approximates 1 minute

// Lost-mode LED pattern: 16 pairs (4 preamble, 8 PID, 4 for lost_minutes)
#define LOST_PATTERN_LENGTH   16
static const uint8_t preamble[4] = { 2, 1, 2, 1 };
static const uint8_t pid_pattern[8] = { 0, 3, 0, 1, 1, 2, 1, 3 };

/* Global array for lost-mode LED pattern (updated when in lost mode) */
volatile uint8_t lost_pattern[LOST_PATTERN_LENGTH];

/* Global flags and counters */
volatile uint8_t lost_mode = 0;     // 0: normal, 1: lost mode
uint32_t static_count = 0;          // Counts consecutive static samples
uint32_t lost_time_counter = 0;     // Lost mode timing counter (for minute increments)
uint8_t lost_minutes = 0;           // Minutes lost since entering lost mode

/* Accelerometer readings */
int16_t prev_ax = 0, prev_ay = 0, prev_az = 0;
int16_t ax = 0, ay = 0, az = 0;

/* BLE messaging timing */
uint32_t lastMessageTick = 0;       // Last time a BLE message was sent

/* Tag name */
const char *tagName = "DS12345";

/* Stub implementations for functions normally generated by CubeMX.
   Replace these with your actual initialization functions if available. */
void SystemClock_Config(void)
{
  /* Stub: implement system clock configuration as needed */
}

void MX_GPIO_Init(void)
{
  /* Stub: implement GPIO initialization
     Ensure that GPIO_LED1 (e.g. PA5) is configured as output.
  */
}

/* Minimal definitions required by BLE code */
SPI_HandleTypeDef hspi3;  // Ensure proper SPI initialization in your project
int dataAvailable = 0;    // This flag should be set by your BLE interrupt handler

/* Redefine _write() for printf() output via ITM */
int _write(int file, char *ptr, int len)
{
  for (int i = 0; i < len; i++)
  {
    ITM_SendChar(*ptr++);
  }
  return len;
}

/**
  * @brief TIM2 Interrupt Handler.
  *        When in lost mode, flashes the lost_mode pattern; otherwise turns off LEDs.
  */
void TIM2_IRQHandler(void)
{
  static uint8_t lost_index = 0;  // Index into lost_pattern

  if (TIM2->SR & TIM_SR_UIF)
  {
    // Clear update flag
    TIM2->SR &= ~TIM_SR_UIF;

    if (lost_mode)
    {
      // Flash the lost-mode pattern
      leds_set(lost_pattern[lost_index]);
      lost_index = (lost_index + 1) % LOST_PATTERN_LENGTH;
    }
    else
    {
      // Not in lost mode: ensure LEDs are off
      leds_set(0);
      lost_index = 0;
    }
  }
}

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();

  /* Initialize drivers */
  i2c_init();
  lsm6dsl_init();
  ble_init();

  /* Initially disable BLE connectivity */
  setDiscoverability(0);

  /* Get an initial accelerometer reading */
  lsm6dsl_read_xyz(&prev_ax, &prev_ay, &prev_az);

  /* Initialize BLE messaging timer */
  lastMessageTick = HAL_GetTick();

  printf("DS12345 PrivTag application started. Monitoring movement...\n");

  /* Main loop */
  while (1)
  {
    /* Read current accelerometer data */
    lsm6dsl_read_xyz(&ax, &ay, &az);

    /* Compute absolute differences between successive readings */
    int diff_x = (ax >= prev_ax) ? (ax - prev_ax) : (prev_ax - ax);
    int diff_y = (ay >= prev_ay) ? (ay - prev_ay) : (prev_ay - ay);
    int diff_z = (az >= prev_az) ? (az - prev_az) : (prev_az - az);

    /* Debug print differences */
    printf("Diff: X=%d, Y=%d, Z=%d\n", diff_x, diff_y, diff_z);

    /* Check if device is static */
    if ((diff_x < MOVEMENT_THRESHOLD) &&
        (diff_y < MOVEMENT_THRESHOLD) &&
        (diff_z < MOVEMENT_THRESHOLD))
    {
      static_count++;
      printf("Static count: %lu\n", static_count);
    }
    else
    {
      /* Movement detected; reset static count and exit lost mode if necessary */
      static_count = 0;
      if (lost_mode)
      {
        lost_mode = 0;
        setDiscoverability(0); // Disable BLE advertising
        printf("Movement detected. Exiting lost mode.\n");
        HAL_GPIO_WritePin(GPIO_LED1_GPIO_Port, GPIO_LED1_Pin, GPIO_PIN_RESET);
      }
    }

    /* Update previous readings */
    prev_ax = ax;
    prev_ay = ay;
    prev_az = az;

    /* Enter lost mode if static count exceeds threshold and not already in lost mode */
    if ((static_count >= LOST_MODE_THRESHOLD) && (!lost_mode))
    {
      lost_mode = 1;
      lost_time_counter = 0;
      lost_minutes = 0;
      setConnectable(); // Enable BLE connectability
      printf("No movement detected for ~5 seconds. Entering lost mode...\n");
    }

    /* If in lost mode, update lost time and rebuild lost-mode LED pattern */
    if (lost_mode)
    {
      lost_time_counter++;  // Assume each loop ~100ms delay
      if (lost_time_counter >= ONE_MINUTE_COUNT)
      {
        lost_minutes++;
        lost_time_counter = 0;
        printf("Lost mode: %d minute(s) elapsed.\n", lost_minutes);
      }

      /* Build lost_mode pattern:
       *   - First 4 pairs: preamble
       *   - Next 8 pairs: PID pattern (for DS12345, represented as 0,3,0,1,1,2,1,3)
       *   - Last 4 pairs: lost_minutes encoded in 8 bits (each pair = 2 bits)
       */
      for (int i = 0; i < 4; i++)
      {
        lost_pattern[i] = preamble[i];
      }
      for (int i = 0; i < 8; i++)
      {
        lost_pattern[4 + i] = pid_pattern[i];
      }
      lost_pattern[12] = (lost_minutes >> 6) & 0x03;
      lost_pattern[13] = (lost_minutes >> 4) & 0x03;
      lost_pattern[14] = (lost_minutes >> 2) & 0x03;
      lost_pattern[15] = (lost_minutes >> 0) & 0x03;

      /* Every 10 seconds, send a BLE message with lost duration */
      uint32_t currentTick = HAL_GetTick();
      if ((currentTick - lastMessageTick) >= 10000)
      {
        // Reassert connectability in case advertising dropped
        setConnectable();
        uint32_t lostSeconds = (currentTick - HAL_GetTick() + static_count * 100) / 1000;  // Approximation
        char message[64];
        snprintf(message, sizeof(message), "PrivTag %s has been missing for %lu seconds", tagName, lostSeconds);

        updateCharValue(NORDIC_UART_SERVICE_HANDLE, READ_CHAR_HANDLE, 0, strlen(message), (uint8_t*)message);
        printf("Sent BLE message: %s\n", message);
        lastMessageTick = currentTick;
      }
    }

    /* Delay between samples (~100ms) */
    HAL_Delay(100);
  }

  return 0;
}
