/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body for PrivTag BLE application.
  *
  * This application integrates BLE proximity detection with lost‚Äêmode detection.
  * The device continuously monitors its LSM6DSL accelerometer. If no significant
  * movement is detected for approximately one minute, the tag enters lost mode.
  * Once in lost mode, the BLE stack is made discoverable and every 10 seconds a
  * message is sent over the BLE virtual UART with the text:
  *
  *   "PrivTag Tag001 missing for <N> s"
  *
  * In this example, TAG_NAME is defined as "Tag001". Update this value as needed.
  *
  * Note: All changes are confined to main.c.
  ******************************************************************************
  */
/* USER CODE END Header */

#include "main.h"       // Includes HAL, CMSIS, etc.
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "stm32l475xx.h"

#include "ble.h"        // BLE stack and ACI commands
#include "leds.h"       // LED driver (not used when BLE messaging is active)
#include "timer.h"      // Timer driver
#include "i2c.h"        // I2C driver for the accelerometer
#include "lsm6dsl.h"    // Accelerometer driver

/* Global variable required by BLE code */
int dataAvailable = 0;

/* SPI handle used by BLE functions */
SPI_HandleTypeDef hspi3;

/* Lost-mode / BLE messaging parameters */
#define TAG_NAME              "Tag001"    // Tag name to include in BLE messages

#define MOVEMENT_THRESHOLD    1200        // Accelerometer threshold for "static"
#define LOST_MODE_THRESHOLD   600         // ~600 consecutive samples (~60 seconds at 100ms delay)
#define BLE_MSG_INTERVAL      10000       // Send BLE message every 10,000 ms (10 seconds)

/* Global variables for lost-mode detection */
volatile uint8_t lost_mode = 0;         // 0 = normal, 1 = lost
volatile uint8_t nonDiscoverable = 1;   // When 1, tag is non-discoverable; set to 0 in lost mode
uint32_t static_count = 0;              // Counter for consecutive static samples
uint32_t lost_start_time = 0;           // Timestamp (ms) when lost mode was entered
uint32_t bleMessageTimer = 0;           // Timer for periodic BLE messages

/* Accelerometer readings */
int16_t ax, ay, az;                     // Current accelerometer readings
int16_t prev_ax, prev_ay, prev_az;        // Previous accelerometer readings

/**
  * @brief TIM2 interrupt handler.
  * In this integration, we disable any LED beacon by turning off the LEDs.
  */
void TIM2_IRQHandler(void)
{
  if (TIM2->SR & TIM_SR_UIF)
  {
    TIM2->SR &= ~TIM_SR_UIF; // Clear update flag
    // Disable LED beacon; BLE messaging is used instead.
    leds_set(0);
  }
}

/**
  * @brief  Redirect printf output via ITM.
  */
int _write(int file, char *ptr, int len)
{
  for (int i = 0; i < len; i++)
  {
    ITM_SendChar(ptr[i]);
  }
  return len;
}

int main(void)
{
  uint32_t currentTime, lostDurationSeconds;
  char msg[64];

  /* MCU and HAL Initialization */
  HAL_Init();
  SystemClock_Config();

  /* Initialize peripherals required by the BLE stack */
  MX_GPIO_Init();
  MX_SPI3_Init();

  // Reset BLE module
  HAL_GPIO_WritePin(BLE_RESET_GPIO_Port, BLE_RESET_Pin, GPIO_PIN_RESET);
  HAL_Delay(10);
  HAL_GPIO_WritePin(BLE_RESET_GPIO_Port, BLE_RESET_Pin, GPIO_PIN_SET);

  /* Initialize BLE stack */
  ble_init();
  HAL_Delay(10);

  /* Initialize PrivTag modules */
  leds_init();            // Initialize LED hardware
  timer_init(TIM2);       // Initialize TIM2 for periodic interrupts
  timer_set_ms(TIM2, 50); // Set TIM2 period to 50 ms
  i2c_init();             // Initialize I2C
  lsm6dsl_init();         // Initialize the LSM6DSL accelerometer

  /* Get an initial accelerometer reading */
  lsm6dsl_read_xyz(&prev_ax, &prev_ay, &prev_az);

  printf("PrivTag BLE application started. Monitoring movement...\n");

  bleMessageTimer = HAL_GetTick();

  /* Main loop */
  while (1)
  {
    currentTime = HAL_GetTick();

    /* Lost Mode Detection */
    lsm6dsl_read_xyz(&ax, &ay, &az);

    // Compute absolute differences between successive readings
    int diff_x = (ax >= prev_ax) ? (ax - prev_ax) : (prev_ax - ax);
    int diff_y = (ay >= prev_ay) ? (ay - prev_ay) : (prev_ay - ay);
    int diff_z = (az >= prev_az) ? (az - prev_az) : (prev_az - az);

    if ((diff_x < MOVEMENT_THRESHOLD) &&
        (diff_y < MOVEMENT_THRESHOLD) &&
        (diff_z < MOVEMENT_THRESHOLD))
    {
      static_count++;
    }
    else
    {
      static_count = 0;
      lost_mode = 0;
      nonDiscoverable = 1;
      lost_start_time = 0;
    }

    // If static for long enough, enter lost mode
    if (static_count >= LOST_MODE_THRESHOLD)
    {
      lost_mode = 1;
      nonDiscoverable = 0;  // Allow BLE connections
      if (lost_start_time == 0)
      {
        lost_start_time = currentTime;
        bleMessageTimer = currentTime;
      }
    }

    // Update previous accelerometer readings for next iteration
    prev_ax = ax;
    prev_ay = ay;
    prev_az = az;

    /* BLE Event Processing */
    if (!nonDiscoverable && HAL_GPIO_ReadPin(BLE_INT_GPIO_Port, BLE_INT_Pin))
    {
      catchBLE();
    }

    /* BLE Messaging in Lost Mode */
    if (lost_mode && (currentTime - bleMessageTimer >= BLE_MSG_INTERVAL))
    {
      lostDurationSeconds = (currentTime - lost_start_time) / 1000;
      sprintf(msg, "PrivTag %s missing for %lus", TAG_NAME, (unsigned int)lostDurationSeconds);
      updateCharValue(NORDIC_UART_SERVICE_HANDLE, READ_CHAR_HANDLE, 0, strlen(msg), (uint8_t *)msg);
      bleMessageTimer = currentTime;
      printf("BLE Message Sent: %s\n", msg);
    }

    /* Debug output */
    printf("Accel: X=%d, Y=%d, Z=%d, lost_mode=%d, static_count=%lu\n",
           ax, ay, az, lost_mode, static_count);

    HAL_Delay(100); // ~100ms delay per loop iteration
  }

  return 0;
}
