/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body for DS12345 PrivTag with BLE.
 *                   This application integrates the I2C/accelerometer drivers
 *                   with BLE functionality (using BlueNRG-MS) to announce when the
 *                   tag has been dropped (i.e. remains static for one minute).
 *
 * When the tag is moving, it remains non-connectable and does not broadcast.
 * When no movement is detected for one minute, the tag enters lost mode,
 * becomes connectable, and every 10 seconds sends over BLE the message:
 * "PrivTag DS12345 has been missing for <N> seconds"
 *
 * Note:
 *   - The tag name is "DS12345" (the last digits of the PID; also mention this
 *     in README.md).
 *   - BLE functions (from ble.h/ble.c) are used to manage connections and data
 *     transmission over the virtual UART.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stm32l475xx.h>
#include "leds.h"
#include "timer.h"
#include "i2c.h"
#include "lsm6dsl.h"
#include "ble.h"

//-------------------------------------------------------------------
// Global definitions for BLE external variables required by ble.c
//-------------------------------------------------------------------
// These definitions satisfy the undefined references in ble.c.
SPI_HandleTypeDef hspi3;        // SPI handle used for BLE communication
volatile int dataAvailable = 0;  // Flag set by BLE interrupt (should be updated elsewhere)

//-------------------------------------------------------------------
// Lost Mode Detection and BLE Messaging Parameters
//-------------------------------------------------------------------
#define MOVEMENT_THRESHOLD    1200    // Maximum change in any axis to consider the device static
#define LOST_MODE_THRESHOLD   600     // 600 consecutive static samples (~1 minute at ~100ms per sample)
#define MESSAGE_INTERVAL_COUNT 100    // ~100 iterations (~10 seconds per message, if each loop ~100ms)

uint32_t static_count = 0;          // Counts consecutive static samples
volatile uint8_t lost_mode = 0;     // 0: normal mode, 1: lost mode
uint32_t message_timer = 0;         // Loop counter for BLE message interval
uint32_t lost_seconds = 0;          // Total seconds lost

// Accelerometer readings
int16_t ax, ay, az;               // Current accelerometer readings
int16_t prev_ax, prev_ay, prev_az;  // Previous accelerometer readings

//-------------------------------------------------------------------
// BLE Message Function
//-------------------------------------------------------------------
/**
 * @brief Sends a BLE message over the virtual UART.
 * The message format is:
 * "PrivTag DS12345 has been missing for <N> seconds"
 *
 * Uses updateCharValue() from the BLE driver to send the message.
 */
void sendBleMessage(uint32_t secondsMissing)
{
    char message[64];
    snprintf(message, sizeof(message), "PrivTag DS12345 has been missing for %lu seconds", secondsMissing);

    // Update the BLE characteristic (assumes that ble_init() has configured the service)
    updateCharValue(NORDIC_UART_SERVICE_HANDLE, READ_CHAR_HANDLE, 0, strlen(message), (uint8_t *)message);

    printf("BLE Message sent: %s\n", message);
}

//-------------------------------------------------------------------
// Timer Interrupt Handler (for LED control)
// In this integration the LED flashing is not used for normal mode,
// but can be used for fallback debugging if needed.
// When not in lost mode, LEDs remain off.
// (BLE is used for messaging instead.)
//-------------------------------------------------------------------
void TIM2_IRQHandler(void)
{
    // Using a simple counter for lost mode LED flashing if needed.
    static uint8_t lost_index = 0;

    if (TIM2->SR & TIM_SR_UIF)
    {
        TIM2->SR &= ~TIM_SR_UIF;
        if (lost_mode)
        {
            // Optionally, flash an LED pattern (lost_pattern) in lost mode.
            // For BLE-only operation, this section can be removed or repurposed.
            // Here we simply toggle both LEDs on (3) and off (0) for visual indication.
            if (lost_index % 2 == 0)
                leds_set(3);
            else
                leds_set(0);
            lost_index++;
        }
        else
        {
            // Ensure LEDs are off in normal mode.
            leds_set(0);
            lost_index = 0;
        }
    }
}

//-------------------------------------------------------------------
// Redirect printf to ITM for debugging output.
//-------------------------------------------------------------------
int _write(int file, char *ptr, int len)
{
    for (int i = 0; i < len; i++)
    {
        ITM_SendChar(*ptr++);
    }
    return len;
}

//-------------------------------------------------------------------
// Main Function
//-------------------------------------------------------------------
int main(void)
{
    // Peripheral Initialization
    leds_init();             // Initialize LED hardware
    timer_init(TIM2);        // Initialize TIM2 for periodic interrupts
    timer_set_ms(TIM2, 50);  // Set TIM2 period to 50 ms (for LED/interrupt tasks)
    i2c_init();              // Initialize I2C (for accelerometer)
    lsm6dsl_init();          // Initialize the LSM6DSL accelerometer
    ble_init();              // Initialize the BLE module

    // Initially, ensure BLE is not connectable.
    // (The BLE module remains non-discoverable until setConnectable() is called.)

    // Get an initial accelerometer reading.
    lsm6dsl_read_xyz(&prev_ax, &prev_ay, &prev_az);

    printf("DS12345 PrivTag started. Monitoring movement...\n");

    // Main loop: monitor movement and manage BLE messaging when lost.
    while (1)
    {
        // Read current accelerometer data.
        lsm6dsl_read_xyz(&ax, &ay, &az);

        // Compute absolute differences between consecutive readings.
        int diff_x = (ax >= prev_ax) ? (ax - prev_ax) : (prev_ax - ax);
        int diff_y = (ay >= prev_ay) ? (ay - prev_ay) : (prev_ay - ay);
        int diff_z = (az >= prev_az) ? (az - prev_az) : (prev_az - az);

        // Check if the device is "static".
        if (diff_x < MOVEMENT_THRESHOLD &&
            diff_y < MOVEMENT_THRESHOLD &&
            diff_z < MOVEMENT_THRESHOLD)
        {
            static_count++;
        }
        else
        {
            // Movement detected; reset static counter.
            static_count = 0;
            if (lost_mode)
            {
                lost_mode = 0;
                message_timer = 0;
                lost_seconds = 0;
                // Optionally disconnect BLE if connected.
                disconnectBLE();
                printf("Movement detected: Exiting lost mode.\n");
            }
        }

        // Enter lost mode if static long enough.
        if (static_count >= LOST_MODE_THRESHOLD)
        {
            if (!lost_mode)
            {
                lost_mode = 1;
                // Make BLE connectable.
                setConnectable();
                printf("Lost mode triggered: Device static for 1 minute. BLE is now connectable.\n");
            }
        }

        // If in lost mode, handle BLE messaging every ~10 seconds.
        if (lost_mode)
        {
            message_timer++;
            if (message_timer >= MESSAGE_INTERVAL_COUNT)
            {
                lost_seconds += 10;
                sendBleMessage(lost_seconds);
                message_timer = 0;
            }
        }

        // Update previous accelerometer readings.
        prev_ax = ax;
        prev_ay = ay;
        prev_az = az;

        // Debug output.
        printf("Accel: X=%d, Y=%d, Z=%d, static_count=%lu, lost_mode=%d, lost_seconds=%lu\n",
               ax, ay, az, static_count, lost_mode, lost_seconds);

        // Delay between samples (~100ms per iteration; adjust as needed).
        for (volatile int i = 0; i < 500000; i++);
    }

    return 0;
}
