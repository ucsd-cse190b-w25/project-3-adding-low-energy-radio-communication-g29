/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body.
  *                   This merged file implements the PrivTag application with
  *                   Bluetooth Low Energy. The device monitors accelerometer
  *                   data; if no movement is detected for one minute, the tag
  *                   enters lost mode. In lost mode, the tag becomes connectable
  *                   over BLE and every 10 seconds sends the message:
  *    "PrivTag <TAG_NAME> has been missing for <N> seconds"
  *                   to any connected smartphone via the BLE virtual UART.
  *
  *  Note: BLE functions (ble_init, ble_set_connectable, updateCharValue) are
  *        assumed to be provided by the youlostit-ble project.
  *
  *  Also, your tag name must be less than 8 characters. (Here we use "PTAG1".)
  *
  *  The last 4 digits of your PID (used in the BLE advertisement) are "3167"
  *  and must be mentioned in your README.md.
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>       // for strlen()
#include
/* Private variables ---------------------------------------------------------*/
SPI_HandleTypeDef hspi3;  // For BLE SPI communication (from BLE project)

// Lost mode detection variables
#define MOVEMENT_THRESHOLD    1200    // Maximum change in any axis to consider "static"
#define LOST_MODE_THRESHOLD   600     // 600 consecutive static samples (~1 minute if ~100ms per sample)

uint32_t static_count = 0;           // Counts consecutive "static" samples

// Accelerometer readings
int16_t ax, ay, az;                  // Current readings
int16_t prev_ax, prev_ay, prev_az;     // Previous readings

// BLE lost mode messaging variables
#define TAG_NAME "PTAG1"              // Your tag name (must be less than 8 characters)
uint32_t lost_mode_start = 0;         // Tick count when lost mode began
uint32_t last_msg_time = 0;           // Last time a BLE message was sent

// Flag to indicate lost mode (0 = normal, 1 = lost)
volatile uint8_t lost_mode = 0;


/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_SPI3_Init(void);

/* USER CODE BEGIN 0 */
/* Redirect printf output to ITM */
int _write(int file, char *ptr, int len)
{
  for (int i = 0; i < len; i++) {
    ITM_SendChar(*ptr++);
  }
  return len;
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* Reset of all peripherals, initialize the Flash interface and the Systick */
  HAL_Init();

  /* Configure the system clock */
  SystemClock_Config();

  /* Initialize all configured peripherals from CubeMX */
  MX_GPIO_Init();
  MX_SPI3_Init();

  /* Reset BLE module */
  HAL_GPIO_WritePin(BLE_RESET_GPIO_Port, BLE_RESET_Pin, GPIO_PIN_RESET);
  HAL_Delay(10);
  HAL_GPIO_WritePin(BLE_RESET_GPIO_Port, BLE_RESET_Pin, GPIO_PIN_SET);

  /* Initialize BLE */
  ble_init();
  // Initially, disallow connections.
  ble_set_connectable(0);

  /* Initialize our PrivTag peripherals */
  leds_init();             // LED initialization
  timer_init(TIM2);        // Timer initialization (for lost mode sampling and LED control)
  timer_set_ms(TIM2, 50);  // Timer interrupt every 50 ms
  i2c_init();              // I2C initialization for accelerometer
  lsm6dsl_init();          // Initialize and configure the LSM6DSL accelerometer

  /* Get an initial accelerometer reading */
  lsm6dsl_read_xyz(&prev_ax, &prev_ay, &prev_az);

  printf("PrivTag application started. Monitoring movement...\n");

  /* Main loop */
  while (1)
  {
    /* Read current accelerometer data */
    lsm6dsl_read_xyz(&ax, &ay, &az);

    /* Compute absolute differences between successive readings */
    int diff_x = (ax >= prev_ax) ? (ax - prev_ax) : (prev_ax - ax);
    int diff_y = (ay >= prev_ay) ? (ay - prev_ay) : (prev_ay - ay);
    int diff_z = (az >= prev_az) ? (az - prev_az) : (prev_az - az);

    /* Check if the device is "static" */
    if (diff_x < MOVEMENT_THRESHOLD &&
        diff_y < MOVEMENT_THRESHOLD &&
        diff_z < MOVEMENT_THRESHOLD)
    {
      static_count++;
    }
    else
    {
      static_count = 0;  // Reset counter if movement is detected
    }

    /* If static for long enough (one minute), enter lost mode */
    if (static_count >= LOST_MODE_THRESHOLD)
    {
      if (!lost_mode) {
        lost_mode = 1;
        lost_mode_start = HAL_GetTick();  // Record when lost mode began
        last_msg_time = lost_mode_start;    // Initialize message timer
        ble_set_connectable(1);             // Allow BLE connections when lost
        printf("Lost mode activated.\n");
      }
    }
    else
    {
      if (lost_mode) {
        lost_mode = 0;
        printf("Lost mode deactivated (movement detected).\n");
        ble_set_connectable(0);  // Disallow BLE connections when not lost
      }
    }

    /* If in lost mode, every 10 seconds send a BLE message over the virtual UART */
    if (lost_mode)
    {
      uint32_t currentTick = HAL_GetTick();
      if ((currentTick - last_msg_time) >= 10000)  // 10,000 ms = 10 seconds
      {
        uint32_t lost_seconds = (currentTick - lost_mode_start) / 1000;
        char msg[80];
        // Format the message. (You may shorten it if BLE packet size is limited.)
        snprintf(msg, sizeof(msg), "PrivTag %s has been missing for %lu seconds", TAG_NAME, lost_seconds);
        // Send the message over BLE virtual UART. Adjust service and char handles as required.
        updateCharValue(NORDIC_UART_SERVICE_HANDLE, READ_CHAR_HANDLE, 0, strlen(msg), (uint8_t*)msg);
        printf("BLE Msg Sent: %s\n", msg);
        last_msg_time = currentTick;
      }
    }

    /* Update previous accelerometer readings for next iteration */
    prev_ax = ax;
    prev_ay = ay;
    prev_az = az;

    /* Optional: delay between samples (roughly 100 ms) */
    HAL_Delay(100);
  }
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the RCC Oscillators */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_7;  // Adjust as needed
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief SPI3 Initialization Function
  * @retval None
  */
static void MX_SPI3_Init(void)
{
  hspi3.Instance = SPI3;
  hspi3.Init.Mode = SPI_MODE_MASTER;
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
  hspi3.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi3.Init.NSS = SPI_NSS_SOFT;
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi3.Init.CRCPolynomial = 7;
  hspi3.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief GPIO Initialization Function
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();

  /* Configure BLE interrupt pin */
  GPIO_InitStruct.Pin = BLE_INT_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BLE_INT_GPIO_Port, &GPIO_InitStruct);

  /* Configure LED and BLE reset pins */
  GPIO_InitStruct.Pin = GPIO_LED1_Pin | BLE_RESET_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* Configure BLE chip select pin */
  GPIO_InitStruct.Pin = BLE_CS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(BLE_CS_GPIO_Port, &GPIO_InitStruct);

  /* Set initial output levels */
  HAL_GPIO_WritePin(GPIO_LED1_GPIO_Port, GPIO_LED1_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(BLE_CS_GPIO_Port, BLE_CS_Pin, GPIO_PIN_SET);
  HAL_GPIO_WritePin(BLE_RESET_GPIO_Port, BLE_RESET_Pin, GPIO_PIN_SET);

  /* Configure EXTI interrupts */
  HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  __disable_irq();
  while (1)
  {
  }
}

#ifdef  USE_FULL_ASSERT
void assert_failed(uint8_t *file, uint32_t line)
{
}
#endif
