/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body for the DS12345 PrivTag BLE application.
  *                   This application uses the I2C accelerometer to detect motion.
  *                   If no movement is detected for 1 minute, the tag enters lost mode.
  *                   In lost mode, the tag becomes connectable via Bluetooth Low Energy
  *                   and every 10 seconds sends a message over the BLE virtual UART in the
  *                   format:
  *                     "PrivTag DS12345 has been missing for <N> seconds"
  *
  *                   (Note: The tag name is DS12345. Be sure to mention the last 4 digits,
  *                   "DS12345", in your README.md.)
  *
  * Relevant datasheets:
  *   - STMicro BlueNRG-MS datasheet Chapter 6 (Operating Modes)
  *   - STMicro BlueNRG-MS ACI documentation
  *   - Bluetooth Core Specification V6
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "i2c.h"
#include "lsm6dsl.h"
#include "ble.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* Private defines -----------------------------------------------------------*/
// Threshold for detecting motion (accelerometer differences less than this value indicate "static")
#define MOVEMENT_THRESHOLD    1200

// Number of consecutive static samples (each sample ~100ms) required to declare "lost" (1 minute = 600 samples)
#define LOST_THRESHOLD        600

/* Private variables ---------------------------------------------------------*/
uint32_t static_count = 0;           // Counts consecutive static samples
uint8_t lost_mode = 0;               // Flag: 0 = normal mode, 1 = lost mode

// Variables for accelerometer readings
int16_t prev_ax = 0, prev_ay = 0, prev_az = 0;
int16_t ax = 0, ay = 0, az = 0;

// BLE messaging timing variables
uint32_t lastMessageTick = 0;        // Timestamp of last BLE message sent
uint32_t lostStartTick = 0;          // Timestamp when lost mode was entered

// Tag name (DS12345 as per instructions)
const char *tagName = "DS12345";

/* USER CODE BEGIN 0 */
// The following functions (SystemClock_Config, MX_GPIO_Init, MX_I2C2_Init, etc.)
// are assumed to be generated by STM32CubeIDE as part of the youlostit-ble project.
// If not already present, please ensure they are implemented appropriately.
// For this implementation, we rely on HAL_Init() and SystemClock_Config() for HAL initialization.
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* Configure the system clock */
  SystemClock_Config();

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  // Note: If the project uses CubeMX-generated I2C initialization, MX_I2C2_Init() may be called.
  // Otherwise, we use our custom I2C driver initialization:
  i2c_init();

  // Initialize the accelerometer via our driver.
  lsm6dsl_init();

  // Initialize the BLE module.
  ble_init();

  // Initially, set BLE to non-discoverable (no connections allowed).
  setDiscoverability(0);

  // Get an initial accelerometer reading.
  lsm6dsl_read_xyz(&prev_ax, &prev_ay, &prev_az);

  // Initialize BLE message timer.
  lastMessageTick = HAL_GetTick();

  printf("DS12345 PrivTag application started. Monitoring movement...\n");

  /* Infinite loop */
  while (1)
  {
    // Read current accelerometer values.
    lsm6dsl_read_xyz(&ax, &ay, &az);

    // Compute absolute differences between consecutive readings.
    int diff_x = (ax >= prev_ax) ? (ax - prev_ax) : (prev_ax - ax);
    int diff_y = (ay >= prev_ay) ? (ay - prev_ay) : (prev_ay - ay);
    int diff_z = (az >= prev_az) ? (az - prev_az) : (prev_az - az);

    // Check if the device is "static" (i.e. changes on all axes are below the threshold).
    if ((diff_x < MOVEMENT_THRESHOLD) &&
        (diff_y < MOVEMENT_THRESHOLD) &&
        (diff_z < MOVEMENT_THRESHOLD))
    {
      static_count++;
    }
    else
    {
      // Movement detected; reset static count and exit lost mode if active.
      static_count = 0;
      if (lost_mode)
      {
        lost_mode = 0;
        // Make device non-discoverable again.
        setDiscoverability(0);
        printf("Movement detected. Exiting lost mode.\n");
      }
    }

    // Update previous accelerometer readings for next iteration.
    prev_ax = ax;
    prev_ay = ay;
    prev_az = az;

    // If static count exceeds threshold and not already in lost mode, enter lost mode.
    if ((static_count >= LOST_THRESHOLD) && (!lost_mode))
    {
      lost_mode = 1;
      lostStartTick = HAL_GetTick();
      // Allow BLE connections.
      setConnectable();
      printf("No movement detected for 1 minute. Entering lost mode...\n");
    }

    // If in lost mode, every 10 seconds send a BLE message.
    if (lost_mode)
    {
      uint32_t currentTick = HAL_GetTick();
      if ((currentTick - lastMessageTick) >= 10000) // 10,000 ms = 10 seconds
      {
        uint32_t lostSeconds = (currentTick - lostStartTick) / 1000;
        char message[64];
        // Format message: "PrivTag DS12345 has been missing for <N> seconds"
        snprintf(message, sizeof(message), "PrivTag %s has been missing for %lu seconds", tagName, lostSeconds);

        // Send the message over BLE via the virtual UART.
        // Here we assume the Nordic UART service has been initialized and
        // the READ_CHAR_HANDLE is used for notifications.
        updateCharValue(NORDIC_UART_SERVICE_HANDLE, READ_CHAR_HANDLE, 0, strlen(message), (uint8_t*)message);

        printf("Sent BLE message: %s\n", message);
        lastMessageTick = currentTick;
      }
    }

    // Delay between accelerometer samples (approx. 100 ms).
    HAL_Delay(100);
  }
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  // User may add his own implementation to report the HAL error return state.
  while(1)
  {
  }
}

/* USER CODE BEGIN 4 */
// Additional user code can be added here if needed.
/* USER CODE END 4 */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
