
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stm32l475xx.h>

#include "leds.h"
#include "timer.h"
#include "i2c.h"
#include "lsm6dsl.h"


#define LOST_PATTERN_LENGTH 16
static const uint8_t preamble[4] = { 2, 1, 2, 1 };
static const uint8_t pid_pattern[8] = { 0, 3, 0, 1, 1, 2, 1, 3 };

// Global array for lost-mode LED pattern.
//   It will be updated with preamble, PID, and minutes lost.
volatile uint8_t lost_pattern[LOST_PATTERN_LENGTH];

// Global flags and counters
volatile uint8_t lost_mode = 0;   // 0: normal mode, 1: lost mode

//Lost mode detection parameters
#define MOVEMENT_THRESHOLD    1200
#define LOST_MODE_THRESHOLD   50     // 50 consecutive static samples (~5 seconds if sampling at ~100ms)


#define ONE_MINUTE_COUNT      600    // Number of main-loop iterations approximating one minute (adjust as needed)
uint32_t lost_time_counter = 0;        // Counter for lost time
uint8_t lost_minutes = 0;              // Minutes lost since entering lost mode

// movement detection
uint32_t static_count = 0;             // Consecutive "static" sample count

//accelerometer readings
int16_t ax, ay, az;                    // Current readings
int16_t prev_ax, prev_ay, prev_az;       // Previous readings
/**
 * @brief TIM2 interrupt handler.
 * When in lost mode, flashes the lost_mode pattern.
 * When not in lost mode, turns off the LEDs.
 */
void TIM2_IRQHandler(void)
{
    static uint8_t lost_index = 0;  // Index into lost_pattern (only used in lost mode)

    if (TIM2->SR & TIM_SR_UIF)
    {
        // Clear the update interrupt flag
        TIM2->SR &= ~TIM_SR_UIF;

        if (lost_mode)
        {
            // Flash the lost-mode pattern
            leds_set(lost_pattern[lost_index]);
            lost_index = (lost_index + 1) % LOST_PATTERN_LENGTH;
        }
        else
        {
            // Not in lost mode: keep LEDs off
            leds_set(0);
            lost_index = 0;  // Reset lost-mode pattern index
        }
    }
}

// Redefine the libc _write() function for printf via ITM
int _write(int file, char *ptr, int len)
{
    for (int i = 0; i < len; i++)
    {
        ITM_SendChar(*ptr++);
    }
    return len;
}

int main(void)
{
    // Peripheral Initialization
    leds_init();            // Initialize LED hardware (leds.c)
    timer_init(TIM2);       // Initialize TIM2 for interrupts
    timer_set_ms(TIM2, 50); // Set TIM2 period to 50 ms (for LED flashing)
    i2c_init();             // Initialize I2C (i2c.c)
    lsm6dsl_init();         // Initialize the LSM6DSL accelerometer (lsm6dsl.c)

    //Get an initial accelerometer reading
    lsm6dsl_read_xyz(&prev_ax, &prev_ay, &prev_az);

    printf("PrivTag application started. Monitoring movement...\n");

    //Lost Mode Detection and Pattern Update
    while (1)
    {
        // Read current accelerometer data
        lsm6dsl_read_xyz(&ax, &ay, &az);

        // Compute absolute differences between successive readings
        int diff_x = (ax >= prev_ax) ? (ax - prev_ax) : (prev_ax - ax);
        int diff_y = (ay >= prev_ay) ? (ay - prev_ay) : (prev_ay - ay);
        int diff_z = (az >= prev_az) ? (az - prev_az) : (prev_az - az);

        // Check if the device is "static" (i.e. changes are small)
        if (diff_x < MOVEMENT_THRESHOLD &&
            diff_y < MOVEMENT_THRESHOLD &&
            diff_z < MOVEMENT_THRESHOLD)
        {
            static_count++;
        }
        else
        {
            static_count = 0;  // Reset if movement is detected
        }

        // Enter lost mode if static long enough; otherwise, remain normal
        if (static_count >= LOST_MODE_THRESHOLD)
        {
            lost_mode = 1;
        }
        else
        {
            lost_mode = 0;
        }

        // If in lost mode, update the lost time counters and rebuild the lost-mode pattern
        if (lost_mode)
        {
            // Increment lost time counter (assume each loop ~100ms; adjust if needed)
            lost_time_counter++;
            if (lost_time_counter >= ONE_MINUTE_COUNT)
            {
                lost_minutes++;      // One more minute has passed
                lost_time_counter = 0;
            }

            /* lost-mode pattern:
             *   - First 4 pairs: preamble
             *   - Next 8 pairs: PID (last four digits "3167")
             *   - Last 4 pairs: lost_minutes encoded in 8 bits (each pair represents 2 bits)
             */
            for (int i = 0; i < 4; i++)
            {
                lost_pattern[i] = preamble[i];
            }
            for (int i = 0; i < 8; i++)
            {
                lost_pattern[4 + i] = pid_pattern[i];
            }
            lost_pattern[12] = (lost_minutes >> 6) & 0x03;
            lost_pattern[13] = (lost_minutes >> 4) & 0x03;
            lost_pattern[14] = (lost_minutes >> 2) & 0x03;
            lost_pattern[15] = (lost_minutes >> 0) & 0x03;
        }
        else
        {
            // Not in lost mode: reset lost-mode time counters
            lost_time_counter = 0;
            lost_minutes = 0;
        }

        // Update previous readings for the next iteration
        prev_ax = ax;
        prev_ay = ay;
        prev_az = az;

        // Optional debug output
        printf("Accel: X=%d, Y=%d, Z=%d, lost_mode=%d, static_count=%lu, lost_minutes=%d\n",
               ax, ay, az, lost_mode, static_count, lost_minutes);

        /* Delay between samples.
           We reduced the busy-wait loop count to sample faster (~100ms per iteration).
           Adjust the value if necessary.
        */
        for (volatile int i = 0; i < 500000; i++);
    }

    return 0;
}
