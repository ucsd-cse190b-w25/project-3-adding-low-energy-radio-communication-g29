/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body for DS12345 PrivTag with BLE.
 *                   This application integrates I2C/accelerometer lost-mode
 *                   detection with BLE connectivity.
 *
 * When the tag is moving, it remains non-connectable and sends no BLE messages.
 * If the tag remains static for approximately 30 seconds, it enters lost mode:
 *   - BLE is enabled (set connectable)
 *   - LED1 is turned on continuously
 *   - Every 10 seconds, the tag sends over the BLE virtual UART the message:
 *       "PrivTag DS12345 has been missing for <N> seconds"
 *
 * NOTE:
 *   - The tag name is "DS12345" (the last digits of your PIDâ€”mention this in README.md).
 *   - This code integrates drivers for I2C, the LSM6DSL accelerometer, timer, LEDs,
 *     and the BLE module (BlueNRG-MS).
 ******************************************************************************
 */

/* Standard and HAL includes */
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "stm32l4xx_hal.h"

/* Peripheral driver includes */
#include "leds.h"
#include "timer.h"
#include "i2c.h"
#include "lsm6dsl.h"
#include "ble.h"

/* Global variables required by BLE code */
SPI_HandleTypeDef hspi3;        // SPI handle used by BLE module
int dataAvailable = 0;          // Flag set by BLE interrupt (updated in EXTI ISR)

/* ---------------- Lost Mode Detection Parameters ---------------- */
#define MOVEMENT_THRESHOLD    1200    // Maximum allowed change in any axis for static detection
#define LOST_MODE_THRESHOLD   200     // 300 consecutive static samples (~30 seconds if each loop ~100ms)
#define MESSAGE_INTERVAL_COUNT 100    // 100 iterations (~10 seconds per message)

uint32_t static_count = 0;          // Counts consecutive static samples
volatile uint8_t lost_mode = 0;     // 0: normal mode, 1: lost mode
uint32_t message_timer = 0;         // Loop counter for BLE messaging interval
uint32_t lost_seconds = 0;          // Total seconds the tag has been lost

/* Accelerometer readings */
int16_t ax, ay, az;               // Current accelerometer readings
int16_t prev_ax, prev_ay, prev_az;  // Previous accelerometer readings

/* ---------------- BLE Lost-Mode LED Pattern (for fallback) ---------------- */
/* (No longer used in lost mode because we want LED1 on continuously) */
#define LOST_PATTERN_LENGTH 16
static const uint8_t preamble[4] = { 2, 1, 2, 1 };
static const uint8_t pid_pattern[8] = { 0, 3, 0, 1, 1, 2, 1, 3 }; // "3167"
volatile uint8_t lost_pattern[LOST_PATTERN_LENGTH];

/* ---------------- System Initialization Prototypes ---------------- */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_SPI3_Init(void);

/* ---------------- Timer Interrupt Handler ------------------
 * When in lost mode, LED1 is turned on continuously.
 * Otherwise, LEDs remain off.
 */
void TIM2_IRQHandler(void)
{
    if (TIM2->SR & TIM_SR_UIF)
    {
        TIM2->SR &= ~TIM_SR_UIF;
        if (lost_mode)
        {
            // Turn on LED1 only (bit 0 set)
            leds_set(1);
        }
        else
        {
            leds_set(0);
        }
    }
}

/* ---------------- Redirect printf to ITM ------------------
 * This function routes printf output to the SWV ITM console.
 */
int _write(int file, char *ptr, int len)
{
    for (int i = 0; i < len; i++)
    {
        ITM_SendChar(*ptr++);
    }
    return len;
}

/* ---------------- BLE Message Function ------------------
 * Sends a BLE message over the virtual UART with the format:
 * "PrivTag DS12345 has been missing for <N> seconds"
 * This message is sent via BLE only (not printed to the console).
 */
void sendBleMessage(uint32_t secondsMissing)
{
    char message[64];
    snprintf(message, sizeof(message), "PrivTag DS12345 has been missing for %lu seconds", secondsMissing);

    // Send the message over BLE by updating the characteristic value.
    updateCharValue(NORDIC_UART_SERVICE_HANDLE, READ_CHAR_HANDLE, 0, strlen(message), (uint8_t *)message);
}

/* ---------------- Main Function ---------------- */
int main(void)
{
    /* HAL initialization and system clock configuration */
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_SPI3_Init();

    /* Reset and initialize the BLE module */
    HAL_GPIO_WritePin(BLE_RESET_GPIO_Port, BLE_RESET_Pin, GPIO_PIN_RESET);
    HAL_Delay(10);
    HAL_GPIO_WritePin(BLE_RESET_GPIO_Port, BLE_RESET_Pin, GPIO_PIN_SET);
    ble_init();
    disconnectBLE();  // Force BLE to start as non-connectable
    HAL_Delay(10);

    /* Initialize remaining peripherals */
    leds_init();             // Initialize LEDs
    timer_init(TIM2);        // Initialize TIM2 for periodic interrupts
    timer_set_ms(TIM2, 50);  // Set TIM2 period to 50 ms (for LED tasks)
    i2c_init();              // Initialize I2C for accelerometer
    lsm6dsl_init();          // Initialize the LSM6DSL accelerometer

    /* Get initial accelerometer reading */
    lsm6dsl_read_xyz(&prev_ax, &prev_ay, &prev_az);

    printf("DS12345 PrivTag started. Monitoring movement...\n");

    /* Main loop: Monitor accelerometer, manage lost mode & BLE messaging */
    while (1)
    {
        /* Read current accelerometer data */
        lsm6dsl_read_xyz(&ax, &ay, &az);

        /* Compute differences between consecutive readings */
        int diff_x = (ax >= prev_ax) ? (ax - prev_ax) : (prev_ax - ax);
        int diff_y = (ay >= prev_ay) ? (ay - prev_ay) : (prev_ay - ay);
        int diff_z = (az >= prev_az) ? (az - prev_az) : (prev_az - az);

        /* Check if the device is static */
        if (diff_x < MOVEMENT_THRESHOLD &&
            diff_y < MOVEMENT_THRESHOLD &&
            diff_z < MOVEMENT_THRESHOLD)
        {
            static_count++;
        }
        else
        {
            static_count = 0;  // Reset if movement is detected
            if (lost_mode)
            {
                lost_mode = 0;
                message_timer = 0;
                lost_seconds = 0;
                disconnectBLE();
                // Optionally, print a debug message if needed.
            }
        }

        /* If static long enough, enter lost mode */
        if (static_count >= LOST_MODE_THRESHOLD)
        {
            if (!lost_mode)
            {
                lost_mode = 1;
                setConnectable();
                printf("Lost mode triggered: Device static for ~30 seconds. BLE is now connectable.\n");
            }
        }
        else
        {
            lost_mode = 0;
        }

        /* In lost mode, update message timer and send BLE message every ~10 seconds */
        if (lost_mode)
        {
            message_timer++;
            if (message_timer >= MESSAGE_INTERVAL_COUNT)
            {
                lost_seconds += 10;  // Increment lost time by 10 seconds
                sendBleMessage(lost_seconds);
                message_timer = 0;
            }
        }
        else
        {
            message_timer = 0;
            lost_seconds = 0;
        }

        /* Update previous accelerometer readings */
        prev_ax = ax;
        prev_ay = ay;
        prev_az = az;

        /* Optional debug output */
        printf("Accel: X=%d, Y=%d, Z=%d, static_count=%lu, lost_mode=%d, lost_seconds=%lu\n",
               ax, ay, az, static_count, lost_mode, lost_seconds);

        /* Delay between iterations (~100ms per loop; adjust if needed) */
        for (volatile int i = 0; i < 500000; i++);
    }

    return 0;
}

/* ---------------- System Clock Configuration ---------------- */
void SystemClock_Config(void)
{
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
    {
        Error_Handler();
    }

    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
    RCC_OscInitStruct.MSIState = RCC_MSI_ON;
    RCC_OscInitStruct.MSICalibrationValue = 0;
    RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_7;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
    {
        Error_Handler();
    }

    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |
                                  RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
    {
        Error_Handler();
    }
}

/* ---------------- SPI3 Initialization ------------------ */
static void MX_SPI3_Init(void)
{
    hspi3.Instance = SPI3;
    hspi3.Init.Mode = SPI_MODE_MASTER;
    hspi3.Init.Direction = SPI_DIRECTION_2LINES;
    hspi3.Init.DataSize = SPI_DATASIZE_8BIT;
    hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
    hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
    hspi3.Init.NSS = SPI_NSS_SOFT;
    hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
    hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
    hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
    hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
    hspi3.Init.CRCPolynomial = 7;
    hspi3.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
    hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
    if (HAL_SPI_Init(&hspi3) != HAL_OK)
    {
        Error_Handler();
    }
}

/* ---------------- GPIO Initialization ------------------ */
static void MX_GPIO_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    /* Enable GPIO Ports Clock */
    __HAL_RCC_GPIOE_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_GPIOD_CLK_ENABLE();
    __HAL_RCC_GPIOC_CLK_ENABLE();

    /* Configure BLE_INT_Pin (for BLE interrupt) */
    GPIO_InitStruct.Pin = BLE_INT_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(BLE_INT_GPIO_Port, &GPIO_InitStruct);

    /* Configure GPIO_LED1_Pin and BLE_RESET_Pin as outputs */
    GPIO_InitStruct.Pin = GPIO_LED1_Pin | BLE_RESET_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Configure BLE_CS_Pin as output */
    GPIO_InitStruct.Pin = BLE_CS_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    HAL_GPIO_Init(BLE_CS_GPIO_Port, &GPIO_InitStruct);

    /* Set initial levels for BLE_CS and BLE_RESET */
    HAL_GPIO_WritePin(BLE_CS_GPIO_Port, BLE_CS_Pin, GPIO_PIN_SET);
    HAL_GPIO_WritePin(BLE_RESET_GPIO_Port, BLE_RESET_Pin, GPIO_PIN_SET);

    /* Configure and enable EXTI interrupt for BLE_INT */
    HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
}

/* ---------------- Error Handler ------------------ */
void Error_Handler(void)
{
    __disable_irq();
    while (1)
    {
    }
}
